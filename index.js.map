{"version":3,"file":"index.js","sources":["source/utils.js","source/types/Array.js","source/types/Boolean.js","source/types/Date.js","source/types/Error.js","source/types/Function.js","source/types/Map.js","source/types/Number.js","source/types/Object.js","source/types/Set.js","source/types/String.js","source/types/Symbol.js","source/types/index.js","source/max-depth.js","source/data.js"],"sourcesContent":["// Assigned to an object, when rendering, if exists, will wrap content, like\n// Map{...} or Set[...]\nexport const CLASS_NAME_KEY = '@class-name';\n\nexport const SPACE_LEVEL = '  ';\nexport const MAX_FUNC_STR_LEN = 30;\n\nexport const setCustomClassNameTo = (data, className) =>\n  (data[CLASS_NAME_KEY] = className);\n\nexport const getCustomClassNameFrom = (data) => data[CLASS_NAME_KEY] || '';\n\nexport const getStringWrap = (value) => {\n  let pre;\n  let post;\n  const name = getCustomClassNameFrom(value);\n\n  if (value instanceof Array) {\n    pre = '[';\n    post = ']';\n  } else {\n    pre = '{';\n    post = '}';\n  }\n\n  pre = `${name}${pre}`;\n\n  return { pre, post };\n};\n\nexport const canPassAsIs = (value) => typeof value === 'string';\n\nconst validKeyRgx = /^[\\w_$][\\w\\d_$]*$/i;\n\nexport const keyNeedsConversion = (key) => !(canPassAsIs(key) && validKeyRgx.test(key));\n\nexport const isNested = (value) => typeof value === 'object';\n\nexport const createComplexDataStorage = () => new Map();\n\nexport const isStorage = (storage) => storage instanceof Map;\n\nexport const addToStorage = (storage, key, value) => storage.set(key, value);\n\nexport const iterateStorage = (storage, handler) => storage.forEach(handler);\n\nexport const getStorageSize = (storage) => storage.size;\n","import { getClassName } from '@actualwave/get-class';\n\nimport { setCustomClassNameTo } from '../utils';\n\nexport default (value, convertValue) => {\n  const result = value.map(convertValue);\n\n  setCustomClassNameTo(result, getClassName(value));\n\n  return result;\n};\n","export default (value) => `${value}`;\n","export default (value) => `Date(${value})`;\n","import {\n  setCustomClassNameTo,\n  createComplexDataStorage,\n  addToStorage,\n} from '../utils';\n\nexport default (value, convertValue) => {\n  const { name, message, columnNumber, fileName, lineNumber } = value;\n\n  const result = createComplexDataStorage();\n\n  addToStorage(result, 'name', convertValue(name));\n  addToStorage(result, 'message', convertValue(message));\n  addToStorage(result, 'columnNumber', convertValue(columnNumber));\n  addToStorage(result, 'fileName', convertValue(fileName));\n  addToStorage(result, 'lineNumber', convertValue(lineNumber));\n\n  setCustomClassNameTo(result, name || 'Error');\n\n  return result;\n};\n","import { getClassName } from '@actualwave/get-class';\n\nimport {\n  MAX_FUNC_STR_LEN,\n  setCustomClassNameTo,\n  createComplexDataStorage,\n  addToStorage,\n} from '../utils';\n\nexport default (value) => {\n  const content = String(value);\n\n  if (content.length <= MAX_FUNC_STR_LEN) {\n    return content;\n  }\n\n  const type = getClassName(value) || 'Function';\n\n  let { name } = value;\n\n  if (!name) {\n    name = content.substr(\n      content.substr(0, 9) === 'function ' ? 9 : 0,\n      MAX_FUNC_STR_LEN,\n    );\n  }\n\n  const result = createComplexDataStorage();\n  addToStorage(result, 'content', content);\n\n  setCustomClassNameTo(\n    result,\n    // FIXME almost every function starts with \"function \", remove this from short string\n    `${type}(${name})`,\n  );\n\n  return result;\n};\n","import { getClassName } from '@actualwave/get-class';\n\nimport {\n  setCustomClassNameTo,\n  createComplexDataStorage,\n  addToStorage,\n} from '../utils';\n\nexport default (value, convertValue) => {\n  const result = createComplexDataStorage();\n\n  value.forEach((item, key) => {\n    /*\n    Do not use keyNeedsConversion() here, because Map may hold values of\n    different types as keys and string should be quoted, otherwise it may be\n    unclear -- what you see string true or boolean true as key.\n    */\n    addToStorage(result, convertValue(key), convertValue(item));\n  });\n\n  setCustomClassNameTo(result, getClassName(value));\n\n  return result;\n};\n","export default (value) => `${value}`;\n","import { getClassName } from '@actualwave/get-class';\n\nimport {\n  setCustomClassNameTo,\n  createComplexDataStorage,\n  addToStorage,\n  keyNeedsConversion,\n} from '../utils';\n\nexport default (value, convertValue) => {\n  const result = createComplexDataStorage();\n\n  Object.keys(value).forEach((key) => {\n    addToStorage(\n      result,\n      keyNeedsConversion(key) ? convertValue(key) : key,\n      convertValue(value[key]),\n    );\n  });\n\n  setCustomClassNameTo(result, getClassName(value));\n\n  return result;\n};\n","import { getClassName } from '@actualwave/get-class';\n\nimport { setCustomClassNameTo } from '../utils';\n\nexport default (value, convertValue) => {\n  const result = [];\n\n  value.forEach((item) => result.push(convertValue(item)));\n\n  setCustomClassNameTo(result, getClassName(value));\n\n  return result;\n};\n","export default (value) => JSON.stringify(value);\n","export default (value) => String(value);\n","import getClass from '@actualwave/get-class';\n\nimport convertArray from './Array';\nimport convertBoolean from './Boolean';\nimport convertDate from './Date';\nimport convertError from './Error';\nimport convertFunction from './Function';\nimport convertMap from './Map';\nimport convertNumber from './Number';\nimport convertObject from './Object';\nimport convertSet from './Set';\nimport convertString from './String';\nimport convertSymbol from './Symbol';\n\n// Every value in JS has .constructor property\n// use Map to store handlers for every type in this case every\n// handler could be replaced and customizable\n\nconst types = new Map();\n\n/**\n * Type handler signature func(value:*, convertType:(value:*)): String|Array|Object;\n * @param {*} constructor\n * @param {*} handler\n */\nexport const addTypeHandler = (constructor, handler) => {\n  if (constructor && handler) {\n    types.delete(constructor);\n    types.set(constructor, handler);\n  }\n};\n\nexport const hasTypeHandler = (constructor) => types.has(constructor);\n\nexport const getTypeHandler = (constructor) => types.get(constructor);\n\nexport const removeTypeHandler = (constructor) => types.delete(constructor);\n\nexport const defaultTypeHandlerSelector = (value) => {\n  const type = getClass(value);\n\n  return type && getTypeHandler(type);\n};\n\nlet typeHandlerSelector = defaultTypeHandlerSelector;\n\n/*\n * Used to get type handler instead of getTypeHandler(), can be customized.\n * @param {*} value\n */\nexport const selectTypeHandler = (value) => typeHandlerSelector(value);\n\n/**\n * Used to customize type selection algorythm, by default it just gets current\n * constructor value and looks for its handler.\n * @param {*} newSelector\n */\nexport const setTypeHandlerSelector = (newSelector) => {\n  typeHandlerSelector = newSelector;\n};\n\naddTypeHandler(Array, convertArray);\naddTypeHandler(Boolean, convertBoolean);\naddTypeHandler(Date, convertDate);\naddTypeHandler(Error, convertError);\naddTypeHandler(Function, convertFunction);\naddTypeHandler(Map, convertMap);\naddTypeHandler(Number, convertNumber);\naddTypeHandler(Object, convertObject);\naddTypeHandler(Set, convertSet);\naddTypeHandler(String, convertString);\naddTypeHandler(Symbol, convertSymbol);\n","import { singleValueFactory } from '@actualwave/closure-value';\r\n\r\nexport const {\r\n  get: getMaxNesingDepth,\r\n  set: setMaxNesingDepth,\r\n} = singleValueFactory(2);\r\n","import convertArray from './types/Array';\nimport convertBoolean from './types/Boolean';\nimport convertDate from './types/Date';\nimport convertError from './types/Error';\nimport convertFunction from './types/Function';\nimport convertMap from './types/Map';\nimport convertNumber from './types/Number';\nimport convertObject from './types/Object';\nimport convertSet from './types/Set';\nimport convertString from './types/String';\nimport convertSymbol from './types/Symbol';\n\nimport { getMaxNesingDepth } from './max-depth';\n\nimport { selectTypeHandler } from './types';\n\nexport const isString = (value) => {\n  switch (typeof value) {\n    case 'symbol':\n    case 'string':\n    case 'boolean':\n    case 'number':\n    case 'undefined':\n      return true;\n    default:\n      return value === null || value instanceof Date;\n  }\n};\n\nexport const toString = (value) => {\n  switch (typeof value) {\n    case 'symbol':\n      return convertSymbol(value);\n    case 'string':\n      return convertString(value);\n    case 'boolean':\n      return convertBoolean(value);\n    case 'number':\n      return convertNumber(value);\n    default:\n      if (value instanceof Date) {\n        return convertDate(value);\n      }\n\n      return `${value}`;\n  }\n};\n\nconst fallbackConversion = (value, convertValue, refs) => {\n  if (isString(value)) {\n    return toString(value);\n  }\n\n  if (value instanceof Function) {\n    return convertFunction(value, convertValue, refs);\n  }\n\n  if (value instanceof Error) {\n    return convertError(value, convertValue, refs);\n  }\n\n  if (value instanceof Map) {\n    return convertMap(value, convertValue, refs);\n  }\n\n  if (value instanceof Set) {\n    return convertSet(value, convertValue, refs);\n  }\n\n  if (value instanceof Array) {\n    return convertArray(value, convertValue, refs);\n  }\n\n  return convertObject(value, convertValue, refs);\n};\n\nexport const convert = (value, level = 1, refs = new Map()) => {\n  if (value === null || value === undefined) {\n    return `${value}`;\n  }\n\n  const maxLevel = getMaxNesingDepth();\n\n  if (level > maxLevel) {\n    return toString(value);\n  }\n\n  const complex = !isString(value);\n\n  if (complex && refs.has(value)) {\n    return refs.get(value);\n  }\n\n  const handler = selectTypeHandler(value);\n  const nextConvert = (propValue) => convert(propValue, level + 1, refs);\n  let result;\n\n  if (handler) {\n    result = handler(value, nextConvert, refs);\n  }\n\n  result = fallbackConversion(value, nextConvert, refs);\n\n  if (complex) {\n    refs.set(value, result);\n  }\n\n  return result;\n};\n"],"names":["CLASS_NAME_KEY","SPACE_LEVEL","MAX_FUNC_STR_LEN","setCustomClassNameTo","data","className","getCustomClassNameFrom","getStringWrap","value","pre","post","name","Array","canPassAsIs","validKeyRgx","keyNeedsConversion","key","test","isNested","createComplexDataStorage","Map","isStorage","storage","addToStorage","set","iterateStorage","handler","forEach","getStorageSize","size","convertValue","result","map","getClassName","message","columnNumber","fileName","lineNumber","content","String","length","type","substr","item","Object","keys","push","JSON","stringify","types","addTypeHandler","constructor","delete","hasTypeHandler","has","getTypeHandler","get","removeTypeHandler","defaultTypeHandlerSelector","getClass","typeHandlerSelector","selectTypeHandler","setTypeHandlerSelector","newSelector","convertArray","Boolean","convertBoolean","Date","convertDate","Error","convertError","Function","convertFunction","convertMap","Number","convertNumber","convertObject","Set","convertSet","convertString","Symbol","convertSymbol","getMaxNesingDepth","setMaxNesingDepth","singleValueFactory","isString","toString","fallbackConversion","refs","convert","level","undefined","maxLevel","complex","nextConvert","propValue"],"mappings":"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"}